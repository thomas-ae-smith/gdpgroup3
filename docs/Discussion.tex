\section{Evaluation}
	\subsection{Summary}
		In this project, we have built and tested a platform for interactive and granular targeted adverts. As part of this, we have developed a tool for content producers to deploy interactive adverts and to create targeted advertising campaigns (targeting criteria for adverts) as well as viewing the statistics pertaining to these.

		We have demonstrated the use of this platform by developing a personalised TV streaming service for tablet devices, Your4, which seamlessly streams a channel to the user with programme content they most enjoy. Within this service, advertising breaks are replaced with adverts which are more likely to be of interest to the user, by taking into account their demographics and the currently playing programme. These adverts provide interactive elements, with an opportunity for creativity via the use of touchscreen gestures and controls.

		The implementation stage of the project details the three major subsystems, and how these interact. This seperation of concerns, achieved with the use of REST services, a client-side application and an industry standard media server, provides a scalable and extendable platform on which to provide the Your4 service. This implementation includes a recommender subsystem to build custom playlists, which learns user preferences from user feedback, via a rating system.

		Two user studies were undertaken. The first of which to determine how users consume media while watching television. The second to evaluate the use of interactive adverts on the Your4 platform. An in depth analysis of the results was documented.
	\subsection{Limitations}
	\subsection{Further work}
		\subsubsection{Programme recommendation}
		\label{sec:further_work_recommender}

		Currently, programmes are assigned binary vectors within $\mathcal{P}$; programmes either do or do not belong in each of the 18 genres. As a result, programme vectors may lie only in the corners of the hypercube geometrically representing $\mathcal{P}$. A logical improvement to the recommender system would be to allow fuzzy genre memberships, allowing programme vectors to exist anywhere within $\mathcal{P}$ and hence allowing fine-grained differences between similar programmes to be properly represented in the system.
		
		To initialize a programme with a fuzzy programme vector, \texttt{get\_programme\_vector} will be required to make use of more information than the current list of programme genres. Possible avenues to explore could include modifying $\mathcal{P}$ such that points are represented by genres pulled from multiple sources and reduced to a lower dimensionality feature space, where the feature space dimensionality would be set to minimise the number of dimensions while maximising the retained information. If additional external information processing is undesirable, user rating data could be used to modify programme vectors which are initialised as binary, although this is only useful in the case of recommending non-live programmes due to the cold start problem \citep{cold-start-problem}.

		If non-binary programme vectors are introduced to $\mathcal{P}$, a change is required in how a user vector is modified upon a negative programme rating. Under the current architecture, a user is pushed away from the vector of a negatively rated programme; if programme vectors exist away from the vertices of $\mathcal{P}$, a user who's vector somehow ends up at a vertex describing programmes they dislike will be unable to move away from the vertex by giving negative ratings, leaving them stuck. This is a difficult problem to solve and is outside the scope of this project; repeated bad ratings must not converge to a single point but explore the programme space, but must not pull a user vector away from a known `good' area. While a jump with random direction may work, storing the users previous rating will allow for exploitation of rating gradients, enabling use of more complex gradient-climbing techniques.

		The addition of implicit user ratings will remove the burden from the user of providing explicit ratings \citep{implicit_indicators}, especially if the rating interface is visually de-emphasised or removed entirely. Few interactions are offered by your4.tv from which to infer ratings from, but programme skipping is provided which carries implicit preference information \cite{exploiting_implicit_feedback}. \citep{recommender-systems-handbook}[p.~304] describe an implicit programme rating $\hat{r}$ calculated from the time a user has watched the programme $p$ and the total programme length $L$:
		$$
			\hat{r} = 3 + 2 \frac{t - 5}{L - 5},\quad 5 \leq t \leq L
		$$
The rating given is between 3 and 5, on a rating scale of 1-5, where play times of under 5 minutes are discarded, and a rating approaches 5 as more of the programme is watched. The implicit ratings gleaned from programme skipping may be made more reliable by asking the user why the programme was skipped; this would allow the rating calculating to consider whether the user does not like the programme, or if the skip was due to another reason (they may have already seen the programme elsewhere). Although this reintroduces the problem of breaking the users pattern of activity, it may be the case that the mental cost to answer why they pressed skip is less than that of giving a rating explicitly.

		%% I think the architecture has changed so this won't work anymore.
		% The current architecture of delivering recommendations to users can be modified to allow for much greater scalability. Currently, each user requests a recommendation and the server responds. If the userbase becomes large enough for this to become infeasable, one solution is to maintain a table of user vector cluster centroids which are updated periodically by a cronjob. Periodically, this table of centroids would be multicast out to all users, along with recommendations for each centroid. 
	\subsubsection{Advert recommendation}

	If recommendation techniques are implemented to improve advert relevance, the data already being collected on user preferences will be of great value in predicting adverts the user will enjoy/engage with. Techniques have been developed \cite{contextual_advertising} which utilize this preference information, along with demographic \cite{contextual_advertising} information, which is also collected by your4.tv. A third data source utilised by the recommender system described by \cite{contextual_advertising} is user viewing histories, which your4.tv does not currently collect, though has potential to improve not only advert recommendations, but also programme recommendations, as mentioned in Section~\ref{sec:further_work_recommender}.

	\subsubsection{Waiting time/recommendation quality trade-off}
	In the current system, programme playlists are constructed in a greedy fashion, using the following algorithm:
	\begin{algorithmic}[H]
	\State start\_timestamp $\gets$ now();
	\State playlist $\gets$ $[]$;
	\While{$($totalTime(playlist) $<$ 7200$)$ \textbf{or} $($len(playlist) $<$ 4$)$}
		\State P $\gets$ $[$all live programmes starting between startTime and startTime+300$]$;
		\If{P not empty}
			\State next\_programme $\gets$ best programme in P;
		\Else
			\State next\_programme $\gets$ best non-live programme;
		\EndIf
		\State playlist.append(next\_programme);
		\State start\_timestamp $\gets$ start\_timestamp + length(next\_programme);
	\EndWhile
	\end{algorithmic}
	This is far from optimum, as programmes with extremely high predicted ratings may start at slightly over 5 minutes after the previous programme ends, leading the programme not to be recommended. By viewing playlist-building as a problem of maximizing predicted programme ratings, minimizing gaps between programmes and prioritizing live TV, this can be seen as a nontrivial constrained optimisation problem, where the trade-off values would need to be determined empirically.

	\subsubsection{Streaming enhancements}
%discuss that timings are too inaccurate.
	While the overarching project aim to create personalised ad replaced streams has been a success there is considerable room for improvement in terms of the ad replacement accuracy. In the presented system we use the MOS records to determine the location of adverts on the client side. These are inserted in the database up to one minute and eight seconds before an advert break starts. However these are at best second accurate and with live shows the exact advert break times can never be known.

	In order to replace adverts it must be known when advert breaks are due to start and finish and hence it is useful to consider the hardware based approach taken by Project4. In the Project4 system the advert replacement process is achieved using a GPI\citep{SCTE104} triggered hardware solution. In digital encoding systems GPI pulses are often used to trigger the next stage in a sequence of precisely timed events. In the project 4 system they receive the planned advert break information on a server with a GPI interface. On receiving this notification, if they have a matching advert break they begin to listen on the GPI interface. Channel 4 send a pulse which is received on the GPI interface precisely 8 seconds before an ad break begins. When this pulse is received it is used to insert markers into the stream with millisecond accurate precision. In the Project4 system a special device known as a PV1000 is used to read these markers and splice the alternate adverts into the stream. This can be seen in \ref{Project4EventFlow}.
	
	The millisecond accuracy achieved by hardware based solutions such as the Project4 system shown in \ref{Project4System} is far preferable to our solution but the splicing process performed by the PV1000 is less than desirable. If this system were used, broadcasters would need to have a splicing device for each and every different advert set. Especially when considering that users may wish to skip adverts it becomes apparent that a splicing device would be needed for every user of the system which is not economically or practically viable.

	Without a GPI trigger or other similar solution millisecond precision is not possible for advert timings. However, we were given access by Inqb8r to the control scripts for a SCTE104 device, which were coded in Python. The SCTE104 is the device which receives the GPI pulse. Using these control scripts we should be able to achieve far greater accuracy, even with live shows by modifying them to ping the LAMP server when the GPI pulse is received, which is precisely 8 seconds before ad ad break is due to start. Assuming a constant network latency or physical proximity of the servers to provide direct communication such as a parallel cable, millisecond accuracy should be possible.
	
	Additionally if future work resulted in successful modification of the SCTE104 control scripts, allowing forwarding of the GPI pulse signal with a constant time, this information could be used to modify the Wowza recording module created for this project to record the shows without adverts included at all. The GPI pulse could effectively start and stop the recordings on the Wowza server whenever the advert breaks start and end. This would result in recordings excluding the adverts entirely. This would mean that replaced advert breaks would not have any advert fragments from before the replacement as the only adverts in the stream would be those inserted for the user.
	
	Completion of this extension would allow a further extension of the project to allow users to schedule their own advert breaks. For example if during an hours viewing 20 minutes of adverts was scheduled, so long as the user watches those 20 minutes at some point the precise timing matters little. This would allow users to watch suspense filled shows without interruption by electing to view enough adverts to meet the quota before their desired show starts.
	
	Finally as mentioned in \ref{sub:StreamCost} individualised streams require falling back to unicast streams which can put significant strain on the broadcaster's servers, increasing costs and reducing economic viability. Because a user could at any time skip an advert there is a potentially infinite number of necessary multicast streams needed at which point there is no benefit to multi-casting the streams. However as mentioned in \ref{sub:StreamCost}, \citet{segmentProxyCaching} and \citet{cachedStream} it is possible to reduce the strain on the broadcaster's servers by using caching proxies to redundantly cache the adverts on many servers. This is particularly useful when the data can be segmented as noted by \citet{segmentProxyCaching}. As we are using the HLS protocol \citet{HLS} which is itself a segmenting protocol our system should benefit significantly from the use of caching proxies and the adjustment of our system to include the usage of these would result in improved economic viability and would help prevent DDOS attacks on the broadcaster's servers.

	\subsection{Conclusion}
In summary our project improves the user experience by making live media personal, targeting both shows and adverts to each user as well as integrating seamlessly with the social experience. Additionally it reduces frustration at missed shows as these are transparently skipped in favour of something the user can watch from the start. In addition it provides a zero-interaction discovery system to remove the time consuming hunt for something to watch and perhaps aid users in discovering new and exciting content. Moreover it improves the experience of consuming adverts by providing users with interactivity, personally targeted adverts and the ability to control which adverts they are shown. 
