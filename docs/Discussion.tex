\section{Discussion}
	\subsection{Summary}
	\subsection{Limitations}
	\subsection{Further Work}
		\subsubsection{Programme Recommendation}
		\label{sec:further_work_recommender}

		Currently, programmes are assigned binary vectors within $\mathcal{P}$; programmes either do or do not belong in each of the 18 genres. As a result, programme vectors may lie only in the corners of the hypercube geometrically representing $\mathcal{P}$. A logical improvement to the reccomender system would be to allow fuzzy genre memberships, allowing programme vectors to exist anywhere within $\mathcal{P}$ and hence allowing fine-grained differences between similar programmes to be properly represented in the system.
		
		To initialize a programme with a fuzzy programme vector, \texttt{get\_programme\_vector} will be required to make use of more information than the current list of programme genres. Possible avenues to explore could include modifying $\mathcal{P}$ such that points are represented by genres pulled from multiple sources and reduced to a lower dimentionality feature space through Principal Component Analysis, where the dimentionality of the feature space would be set to minimise the number of dimensions while maximising the retained information. If additional external information processing is undesirable, user rating data could be used to modify programme vectors which are initialised as binary, although this is only useful in the case of recommending non-live programmes due to the cold start problem\cite{cold-start-problem}.

		If non-binary programme vectors are introduced to $\mathcal{P}$, a change is required in how a user vector is modified upon a negative programme rating. Under the current architecture, a user is pushed away from the vector of a negatively rated programme; if programme vectors exist away from the vertices of $\mathcal{P}$, a user whos vector somehow ends up at a vertex describing programmes they dont like will be unable to move away from the vertex by giving negative ratings, leaving them stuck. This is a difficult problem to solve and is outside the scope of this project; repeated bad ratings must not converge to a single point but explore the programme space. While a jump with random direction may work, storing the users previous rating will allow for exploitation of rating gradients, enabling use of more complex techniques.

		%% I think the architecture has changed so this won't work anymore.
		% The current architecture of delivering recommendations to users can be modified to allow for much greater scalability. Currently, each user requests a recommendation and the server responds. If the userbase becomes large enough for this to become infeasable, one solution is to maintain a table of user vector cluster centroids which are updated periodically by a cronjob. Periodically, this table of centroids would be multicast out to all users, along with recommendations for each centroid. 
	\subsubsection{Advert Recommendation}

	* Recommending advers using user preference data is obv better.

	\subsection{Conclusion}
