\section{Design}

\subsection{System Layers}
The user must be able to access the app via a web browser.

It was decided that the TV and programme streams should be delivered to the client via Wowza media server, which would be run on a Windows server. Peter Wood (inqb8r) has had extensive experience with Wowza, and was able promptly to have the server configured to stream, releaving us of any lengthy configuring that might have had to take place with any other system. Additionally, inqb8r were able to provide us with a licensed Wowza server.

LAMP server

\subsection{Programme Recommendation}

A your4.tv user is presented with a personal channel populated with a list of programmes as recommended by a programme recommendation system.  This system only recommends programmes, and is separate from the targetted advert retreiver (described in Section~\ref{sec:design_adverts}). At an abstract level, each programme is given a vector $\mathbf{p}$, which describes what the programme is like. The vector $\mathbf{p}$ lies within the programme space $\mathcal{P}$, and is calculated using the function \texttt{get\_programme\_vector} from programme information. The concrete implementation of this used in your4.tv is that $\mathcal{P}$ is 19-dimentional, where each dimention represents one of the genres:
\begin{center}
	\emph{\footnotesize{
		\begin{tabular}{c c c c c}
			Action and Adventure & Animation & Children & Comedy & Documentary \\
			Drama & Game Show & Home and Garden & Mini-Series & News \\
			Reality & Science-Fiction & Fantasy & Soap & Special Interest \\
			Sport & Talk Show & Western & Unclassified & 
		\end{tabular} 
	}}
\end{center}
which is the full set of allowable genres on The Tvdb\footnote{\url{http://thetvdb.com/}} plus `Unclassified', which is reserved for programmes which \texttt{get\_programme\_vector} cannot assign an appropriate vector. To map a programme into this space, \texttt{get\_programme\_vector} uses the supplied programme name to query the Tvdb api\footnote{\url{http://thetvdb.com/wiki/index.php/Programmers_API}} for a programme's genres, and returns a binary vector of genre memberships (for each element: 1 if the programme belongs in genre; 0 otherwise). As an example, the programme `Grand Designs' has genres \emph{Documentary}, \emph{Home and Garden} and \emph{Reality}, so would be assigned the vector $\left[0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0\right]$.

So that a user may be recommended programmes, each user is given a vector, $\mathbf{u}$, also within the space $\mathcal{P}$, which represents the users ideal programme. The vector is initialised with the function \texttt{get\_user\_vector}, which takes a vector of a users demographic information, $\mathbf{d}$, and returns the user vector, $\mathbf{u}$. The function \texttt{get\_user\_vector} is learned using a set of training data containing mappings between users, their demographics and shows they enjoy. While a user uses your4.tv, their actions influence their user vector. Upon giving a programme a rating, $\mathbf{u}$ is moved either towards or away from $\mathbf{p}$ by an amount which depends upon the magnitude of the rating, the initial distance between $\mathbf{u}$ and $\mathbf{p}$, and the learning rate of the recommender which may be tweaked or made inversely proportional to the number of ratings made by the user. The exact change to $\mathbf{u}$, where $\mathbf{u}_{i}$ is the $i_{th}$ component of vector $\mathbf{u}$, $\mathbf{u}'$ is the new user vector, $0 \leq L \leq 1$ is the learning rate and $-1 \leq r \leq 1$ is the rating given is given by:

% Can use dcases in mathtools to make the fractions in the conditional more readable (bigger).
$$
	\mathbf{u}_{i}' =
	\mathbf{u}_{i} + \begin{cases}
		\left|\mathbf{p}_{i}-\mathbf{u}_{i}\right|Lr \times \frac{\mathbf{p}_{i}-\mathbf{u}_{i}}{\left|\mathbf{p}_{i}-\mathbf{u}_{i}\right|},&
			\text{if } r\geq 0\\
		(1-\left|\mathbf{p}_{i}-\mathbf{u}_{i}\right|)Lr \times \frac{\mathbf{p}_{i}-\mathbf{u}_{i}}{\left|\mathbf{p}_{i}-\mathbf{u}_{i}\right|},&
			\text{otherwise}
	\end{cases}
$$
Because of division by 0 for the case when the user and programme vectors are, on a particular dimension, identical ($\mathbf{p}_{i}-\mathbf{u}_{i}=0$), a special case was required:
$$
	\mathbf{u}_{i}' =
	\mathbf{u}_{i} + \begin{cases}
		0,&
			\text{if } r\geq 0\\
		\operatorname{sign}(\operatorname{random}()-0.5)\times Lr,&
			\text{otherwise}
	\end{cases}
$$

Genres from Tvdb were chosen as a basis for $\mathcal{P}$ instead of the Project4 or Atlas genres, as this solved the problem of finding training data for the learned function \texttt{get\_user\_vector}. No programme viewing data was available using Project4 or Atlas genres, so the MovieLens 1M dataset\footnote{\url{http://www.grouplens.org/node/73}} was downloaded, and the movies mapped to their corresponding Tvdb genres, giving a large dataset of user demographics, movie ratings, and movie vectors within the programme space $\mathcal{P}$ which serve as suitable training data. To map new programmes into the $\mathcal{P}$, \texttt{get\_programme\_vector} looks up the Tvdb genres for a given programme, using these to construct $\mathbf{p}$.

The space $\mathcal{P}$ is, by design, coupled only with the functions \texttt{get\_user\_vector} and \texttt{get\_programme\_vector}. As a result of this, \texttt{get\_programme\_vector} may be modified, changing the structure of $\mathcal{P}$, as long as \texttt{get\_user\_vector} is re-learnt using the new programme representation. This is desirable, as programme representations better suited to recommendation are possible; i.e., more similar programmes are closer together, more different programmes are further apart, and similar programmes are not given identical representations. Possible ways of accomplishing this are discussed in ****REFERENCE****.


\subsection{Adverts}
\label{sec:design_adverts}

Targetted adverts are shown in your4.tv during programme advert breaks, replacing the adverts which would otherwise appear. Users are able to skip an advert, prompting a box asking the reason they chose to skip the advert, possibly resulting in it being blacklisted for the user. Skipping adverts does not reduce the amount of time the user spends watching adverts, instead simply allows the collection of user preference data and replaces the advert for another which the user hopefully finds more relevant.

Each advert is assigned to a campaign, where a campaign has multiple adverts and an advert may apply to multiple campaigns. A campaign may be given a set of restrictions, where the adverts belonging to a campaign are shown whenever the restrictions are met. Restrictions may apply to programmes, users and times, where the restrictable attributes are:

\begin{center}
	\begin{tabular}{c c r l}
		\textbf{Programmes} & \textbf{Times} & \multicolumn{2}{c}{\textbf{Users}} \\
		\hline
		genre & time of day & ~~gender & latitude \\ % The two non-breaking spaces are so the table looke a little nicer.
		individual programme & weekday & age & longitude \\
		liveness & & &  occupation \\
	\end{tabular}
\end{center}

Attributes may have multiple restrictions, where the restrictions are single points or ranges where appropriate. When a campaign has multiple restrictions on a single attribute, that attribute is considered satisfied if any of its restrictions are satisfied; e.g.: if a campaign has weekday restrictions of Monday and Wednesday, the weekday restriction is considered satisfied on either a Monday or a Wednesday. A campaign only applies when all of its restrictions are satisfied, though a campaign need not have restrictions for all of the above attributes, or indeed any restrictions at all.

Whenever a campaign is satisfied, its adverts are shown with a frequency directly proportional to the value of a campaign metric we are calling nicheness, defined as:
$$
	\text{nicheness} = \frac{(1-\text{nicheness}_\text{programme}) + (1-\text{nicheness}_\text{time}) + (1-\text{nicheness}_\text{user})}{3}
$$
where
\begin{align*}
	\text{nicheness}_\text{programme} &= 1 - \frac{\text{satisfying programmes}}{\text{total programmes}} \\
	\text{nicheness}_\text{time} &= 1 - \frac{\text{satisfied time during campaign}}{\text{total time during campaign}} \\
	\text{nicheness}_\text{user} &= 1 - \frac{\text{satisfying users}}{\text{total users}}
\end{align*}
meaning that for a particular person, programme and time in which multiple campaigns apply, more niche campaigns will have their adverts display more often. This design decision was made to reward advertisers for creating niche campaigns over broad campaigns. By encouraging a greater number of more highly targetted advertisements in this way, users will be shown a far more relevant advert set. According to our prestudy (section \ref{sec:prestudy}), such relevance has a large influence on user attentivity, and is also known to positively influences the user experience\cite{yahoo-intrusive-advertising}.

\subsection{Streaming}
Each programme will be recorded using the EPG data. Since adverts will be replaced by ones recommended to viewers, it must be known when adverts are due to start and finish. This information is available as a GPI[?] pulse, sent by Channel 4 [more technical details]

- detail of stream origin and how many systems it goes through before reaching us
- detail about any delay this may cause
- what limitations are imposed by this? is useful data stripped? does the delay cause inaccuracies?

