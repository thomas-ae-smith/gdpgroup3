\section{Implementation}

The proposed platform consists of several aspects. Firstly, an interface for tablet computers will need to be devised in order to allow users to watch TV. 

Programme recommendation

Advert campaigns

In the following section, the technical details of the implemented system, \textit{Your4.tv}, will be discussed. This includes the overall systems architecture, database design, and the languages and tools used during the development process.

\subsection{Platform}

Apple iPad
Modern web browser

\subsection{System Layers}
The user must be able to access the app via a web browser.

It was decided that the TV and programme streams should be delivered to the client via Wowza media server, which would be hosted on a machine running Windows Server 2008. Peter Wood (Inqb8r) has had extensive experience with Wowza, and assisted Dexter in the configuration of the server to output the Channel 4 streams. This helped by relieving us of any lengthy configuring that might have had to take place with any other system. Additionally, Inqb8r were able to provide us with a licensed Wowza server.

LAMP server


\subsection{Streaming}
The Wowza server will be configured to act as a repeater, re-broadcasting the streams provided by Inqb8r. The Cupertino streaming packetiser will be used to output the streams in the HLS format such that the videos may be viewed on iPads and any other devices supporting this technology. Each programme will be recorded using the EPG data. Since adverts will be replaced by ones recommended to viewers, it must be known when adverts are due to start and finish. This process is achieved by Project4 using a GPI\citep{SCTE104} triggered hardware solution utilising an SCTE 104 Server, a Tanberg Encoder and a PV1000 Ad replacement device as described in \ref{subsubsec:Project4Tech}. Finally the Wowza server will be configured with the standard extension ``vod'' which allows any file of a valid format in a given directory to be streamed.

\subsubsection{Project 4 Advert Replacement: Hardware Solution}\label{subsubsec:Project4Tech}
Ad break information is sent to a Miranda Xplayer Server from Channel 4 via an automation system which forwards this information as XML to a SCTE 104 device. This information is received via HTTP when the SCTE server is running in HTTP Server mode. Ad information is received on this interface 1 minute and 8 seconds before the Ad break is due to start. On receiving this information it checks with a PV1000 substitution device for a matching Ad break, see \citep{PV1000Schedule}. If it finds one it starts listening for a GPI pulse, sent from the automation system which when triggered instructs the Tanberg Encoder which encodes the video stream to insert markers around the ad breaks. This pulse is received 8 seconds before airing. The PV1000 devices then detect these markers and replace the ad break with one they have created\ref{Project4EventFlow}.

\paragraph{PV1000 Schedule}\label{PV1000Schedule}
The PV1000 receives its schedule from the TMS server. The TMS server receives EPG information from the princess server which pulls it from an EPG ftp service. A user uploaded Channel 4 schedule is also provided to the TMS server 2 weeks in advance. The calculated ad breaks are then provided to the PV1000.

\subsubsection{Your4 Advert Replacement: Software Solution}
When the XML data is received defining the ad breaks as described in \ref{subsubsec:Project4Tech} the information (known as a MOS record) is also stored in a MySQL database. This database also includes EPG information We have been given access to this database and thus (excluding network delays) we are able to discover the existence of Ad breaks up to 1 minute and 8 seconds before they are shown. This information will then made available via the your4 REST interface and the clients will use this warning to call the advert recommender to determine which adverts should be shown in place of the existing ones (see Section~\ref{sec:design_adverts}). These adverts will then be streamed as separate files from the Wowza server using the ``vod'' extension.

\subsubsection{Recordings}
The Wowza server will be configured to include the standard extension ``Live Stream Record'' which allows the use of HTTP to record any active streams to a given file. A restriction of this module is that only 1 recording of each stream is permitted. A custom Wowza ServerListener module will be created which will start with the server. This module will continuously poll the your4 REST interface for any shows due to start in the next minute. This information will be retrieved from Atlas in advance by a cron job on the LAMP server as described in \ref{subsec:ScheduledTasks}. When a new show starts any current recording on the channel will be stopped resulting in a streamable file which will be placed in the directory that the ``vod'' extension is configured to use. This file may then be streamed at any time until it is deleted. Once the current recording is stopped a new one will be started to record the new show. By making a new recording end existing recordings we ensure mutual exclusion for each stream, this is required as the ``LiveStreamRecord'' extension only allows a single recorder on each stream. After a configurable period of time the recording will then be removed from the list of recordings but will only be deleted after a further period of time `t' has elapsed where `t' is the length of the video, allowing any existing streamers to finish watching before it is removed. Throughout this process the Wowza module will also use the REST interface to detail the state of any given program where valid states are: ``Not Recorded, Recording, Recorded, Deleted.''

\subsubsection{Restrictions}
Without a GPI trigger millisecond precision is not possible for advert timings but assuming the network delay remains approximately constant second accuracy should be possible in most situations. Unfortunately live shows can result in these times being slightly out so in some cases the information may be incorrect. We have been given access by Inqb8r to the SCTE 104 control scripts which are coded in Python. Using these we should be able to minimise this risk by pinging the Wowza server and the LAMP server when the GPI pulse is received which is precisely 8 seconds before ad ad break is due to start. Additionally this information could be used to start and stop the recordings on the Wowza server resulting in recordings excluding the adverts allowing potential insertion of adverts at the user's discretion, allowing them to choose when to watch the adverts. However due to the lack of an available development device and the difficulty of modifying the scripts to perform our tasks without interfering with the existing Project4 tasks it has been decided that using this information is outside the scope of this project.




\subsection{Systems Architecture \& Description}

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{images/your4-architecture.png}
	\caption{Overview of Your4 architecture}
	\label{fig:your4-architecture}
\end{figure}

Figure~\ref{fig:your4-architecture} shows the overall architecture of the Your4 system. The system is split into three distinct parts:

\begin{description}
	\item[Client] The client (expected to be Mobile Safari for iPad running on top of iOS 5+) is responsible for for interfacing with the LAMP server to retrieve the users' personalised playlist. With this playlist, the player in the client can then request the appropriate media from the media server.
	\item[LAMP server] The LAMP server represents the bulk of the system and is responsible for providing a REST API for the key features of Your4: recommendations, user authentication, electronic programme guide (EPG) data and advert uploading \& manipulation.
	\item[Media server] The media server is responsible for encoding and serving live streams as well as recording programmes and serving recorded programmes.
\end{description}

\subsubsection{Client}

The client receives all HTML content from the LAMP server upon the first visit of your4.tv. From this point onwards, all communication between the client and LAMP server contains only models and collections (e.g. a programme and all of its attributes) on the LAMP servers REST interface in JSON format. The client side application is then responsible for parsing this JSON response and manipulating the user interface using local templates (embedded in the HTML upon the initial page load) as appropriate. Due to the asynchronicity this approach brings, a significant UI speed increase can be observed against traditional methods whereby the web browser acts as a ``thin client'', by simply parsing and rendering HTML responses pre-generated server side.

Using the POST, GET, PUT and DELETE methods in HTTP requests to the REST endpoint maps to the equivalent CRUD (create, read, update and delete) operations on the object concerned. This methodology creates a simple self-documenting API. In a similar exploitation of HTTP philosophies, HTTP status codes are used to identify the status of a request. For example, 200 indicates success and 400 indicates the request was invalid (failed server side validation). The client can then perform the appropriate callback function to manipulate the interface.

\paragraph{Authentication}

The concept of a ``user'' is key to the system since crucial demographics data and matrices defining recommender state are stored against each user. The client authenticates a user by either local login or using the Facebook login API\footnote{\footurl{https://developers.facebook.com/docs/concepts/login}}. Upon page load, the client attempts to retrieve ``/api/users/me'' from the server to discover if an active session is available. If so, the player layers will be rendered on screen, otherwise, the user will be routed to the login interface.

The user can then choose to use the local login which will generate a GET request with the email and password as query parameters. If a 200 response is received, the login is considered to be successful. A user can also choose to login via Facebook. After the user accepts the Facebook permissions, a local cookie is set and a GET request is generated to ``/api/users/fb-[facebook\_id]'' where ``[facebook\_id]'' is retrieved from the Facebook API.

\paragraph{Playback}

Upon initialisation of the player, a number of layers are rendered on top of one another:

\begin{description}
	\item[Video layer] The video component to show video. If on an Apple device, this is a HTML5 video tag. Otherwise, a flash video player is instantiated.
	\item[Skip layer] Contains user controls to skip and rate currently playing media.
	\item[Black layer] Used to hide buffering video in order to provide more seamless stream.
	\item[Overlay layer] An iFrame which displays the HTML that the advertiser has specified to be overlayed on their advert.
\end{description}

Once rendering is complete, the client requests a number of resources from the REST API in order to compile and play a playlist:

\begin{enumerate}
	\item A list of channels including the relevant stream URL to the media server.
	\item The current LAMP server timestamp. This is used in recommendation requests.
	\item A request is made for the best recommended live broadcast. This recommendation is based on the currently playing program on each channel. Live broadcasts are given priority over recorded programmes as this is close to the ``personal TV channel'' ideal. The current timestamp and user ID is sent with this request in order for the server to determine what suitable programmes are upcoming. If a 200 response is received, the body will include the channel ID. If a 404 is received, no appropriate live broadcast recommendation is available. The client will then request a recorded programme recommendation. In both cases, the response also includes the programme ID from the EPG and the location of ad breaks.
	\item With the programme ID, a request is made to retrieve the programme data such as name, description and length.
	\item Between each recorded programme a 2 minute ad break is artificially included. Up to 5 minutes is allowed between live broadcasts (depending on previous programme end and the start of the live broadcast). The system is also aware of ad breaks in programmes within the playlist. For each ad break, a request is made containing: the user ID; programme ID; the amount of time in the ad break; if the ad break is between a live or recorded programme and finally, a list of advert ID's which have already been listed in the playlist. Using this data, the LAMP server can select adverts that match the users demographics and the currently playing programme. This step is repeated multiple times, reducing the amount of time left unallocated in the request each time, until all ad breaks are full.
	\item Steps 3 to 5 are repeated until the minimum duration and size of playlist are both satisfied. Upon each repeat, the timestamp sent with the request is set to the end time of the previously recommended programme or advert. This informs the recommender as to the point in time it should check live broadcasts for suitable programmes.
	\item The playlist is rendered on screen.
	\item The video player is instructed to play the first stream URL in the playlist. Each time an item in the playlist ends, a signal is triggered which causes the player to play the next stream. As well as this, another recommendation is requested and added to the playlist.
\end{enumerate}

The client checks the user agent string of the browser to determine what format of media to request from the media server. Apple devices require HTTP Live Streaming (HLS) streams while the flash player alternative requests an RTMP alternative.

\subsubsection{LAMP Server}

The LAMP server's primary responsibility is to expose all required functionality on a single REST endpoint, ``/api''. In general, the LAMP server deals with a request by passing it through various stages before finally manipulating the database:

\begin{enumerate}
	\item A HTTP request is retrieved by the web server.
	\item The request is passed to the REST API where the appropriate function is called dependant on the request URI and HTTP method.
	\item The object in the request body is passed into the Object Relational Mapper.
	\item The ORM builds the approproate SQL query and passes it to the DBMS.
	\item The DBMS modifies or retrieves from the data store.
	\item The application logic returns the result as a HTTP response containing a JSON body.
\end{enumerate}

\paragraph{Authentication}

Upon registration, name, email, gender, date of birth, occupation, postcode and password are required. For Facebook logins, a facebook ID is required in place of the password. Passwords are stored with a Blowfish-based hash type with a per-user 22 character salt and a 1024 iteration cost parameter which prevents rainbow table exploitation in a human lifetime \citep{hashing}. The postcode is converted to latitude \& longitude coordinates based on ordnance survey data. Upon successful authentication, a session cookie is created.

A recommender function is also called which retrieves the user's initial vector. This is based upon the required demographics data provided at registration. This vector is then stored agaist the user in the database.

\paragraph{Programme Recommendations}

Daily, EPG data is imported from the Atlas API\footnote{\footurl{http://atlas.metabroadcast.com}} into the Your4 database. This contains unique programme ID's, descriptions, episode numbers and other programme data.

Upon first initialisation of the recommender, a CSV file containing training data from the GroupLens research group\footnote{\footurl{http://www.grouplens.org/node/73}} is processed. This gives the recommender an initial estimate as to what type of users prefer what genres. Upon execution of the aforementioned EPG cron job, each programme is passed to a recommender function to retrieve the initial programme vector to store against it. This function calls the genre API, TVDB\footnote{\footurl{http://thetvdb.com}}, to identify this vector. The vector is a 1-dimensional matrix whereby each position represents a predefined genre. A ``1'' indicates the programme belongs to a genre.

Upon receiving a live recommendation request, the recommender selects programmes starting within the next 5 minutes of the timestamp contained in the request (see step 3 in aforementioned playback steps). The recommender then filters out programmes the requesting user has already viewed in the past, and selects the best one according the recommender output. If no suitable live recommendation can be made, a 404 will be returned and the client will request a recorded programme. The recommender then executes a similar process to the live request, but filters programmes by those which have been recorded by the media server.

When a user rates a programme on the client, a request is received by the recommender. This rating is a 5-star system which maps to -1, -0.5, 0, 0.5 and 1 respectively. Upon this request, the recommender tunes the users vector accordingly. The act of rating also adds the programme to the list of already viewed programmes for a user.

\paragraph{Adverts}

Data pertaining to the times ad breaks are positioned during programmes are imported regularly from Project4 systems. Project4 employs a hardware solution to detect these ad breaks. With this data, the client is able to know at which points in time it should request an advert to replace the adverts provided in stream by the broadcaster.

Upon uploading of an advert, an FTP session is instantiated by the LAMP server to the media server. The advert is then uploaded to the media server where it is stored alongside other adverts and recorded programmes. An interactive overlay can also be specified, which will be used in the body of the iFrame element of the overlay layer during playback. Campaign information such as target locations, programmes, gender, age and other specifics can also be specified for storage against the advert in the Your4 database. The advertiser can also specify the times of day (on a per-day basis) and the programmes that they wish their advert to be shown in.

When the client requests an advert, the amount of time the advert has to fill and the ID's of adverts that have already been scheduled in the ad break are included in the request. The LAMP server then performs a search on the database for adverts that match these characteristics (duration less or equal than the remaining ad break time left and the advert has not been shown already in this ad break) and the targeting criterion set by the advertiser. Any adverts the user has shown a dislike for in the past will also be filtered out.

Views, clicks and skips are recorded by the client and feedback is sent to the REST interface. The advertiser can then view these statistics.

\subsubsection{Media Server}

The media server is based on two distinct applications. The first application is responsible for retrieving the source live streams and relaying these to the client. The second is responsible for streaming recorded programmes and adverts from the video store to the client. Both applications use a ``packetizer'' which is responsible for encoding the raw input streams to the output requested (HLS for Apple based devices).

The live application is also responsible for recording programmes. A REST API call is made to the LAMP server to retrieve start and end times of programmes. Using this data, the application records each programme on each channel and stores the resulting media in the video store. This media is stored with a filename which matches that of the unique ID in the EPG. This allows the client to implicitly build the video URL to request when a recorded programme recommendation is made. When a recording starts, the application updates the ``recordState'' flag of the programme via the REST interface. This flag is updated again when recording is completed. Using the state of this flag, the recommender is able to filter out programmes which have not yet been recorded during recorded programme recommendation. The recordings application can then stream these media files to the client when requested.

\subsection{Database structure}

\begin{figure}[H]
	\centering
	\includegraphics[trim = 0 3.7cm 3.5cm 0, clip, width=\textwidth]{images/your4-db.pdf}
	\caption{Overview of Your4 database layout}
	\label{fig:your4-db}
\end{figure}

Figure~\ref{fig:your4-db} shows the Your4 database class diagram. The Object Relational Mapper (ORM) in use enforces a strict naming policy in which all table and attributes are in lower case and are not pluralised. The underscore character represents a relation, e.g. ``programme\_id'' represents a foreign key to the ``id'' attribute in the programme table.

\subsection{Programming Techniques \& Languages}

\subsubsection{Libraries and Frameworks}

A number of libraries and technologies were used during the implementation stage:

\begin{description}
	\item[Client] \hfill
		\begin{description}
			\item[JQuery] asdas asdas asdas asdas asdas 
			\item[Underscore] asdas asdas asdas asdas asdas 
			\item[Backbone] asdas asdas 
			\item[Flowplayer] asdas asdas 
			\item[Bootstrap] asdas asdas asdas asdas 
			\item[D3] asdas asdas asdas asdas asdas asdas 
			\item[Leaflet] asdas asdas 
			\item[Facebook]
		\end{description}
	\item[LAMP Server] \hfill
		\begin{description}
			\item[MySQL]
			\item[Slim]
			\item[RedBean]
			\item[Facebook]
			\item[TVDB]
			\item[NumPy]
		\end{description}
	\item[Media Server] \hfill
		\begin{description}
			\item[Wowza]
			\item[LiveStreamRecord]
			\item[Gson]
		\end{description}
\end{description}

Mysql
slim
redbean
jquery
leaflet
backbone
underscore
bootstrap
flowplayer
d3
numpy
tvdb - caching
wowza
LiveStreamRecord
gson




\subsubsection{Code Statistics}
Lines of code in JS, PHP, Java, Python, HTML, CSS etc

\subsection{System walkthrough}
\begin{figure}[th]
	\centering
	\includegraphics[width=\textwidth]{images/screenshots/your4-login.png}
	\caption{Log in}
	\label{fig:your4-login}
\end{figure}
\begin{figure}[th]
	\centering
	\includegraphics[width=\textwidth]{images/screenshots/your4-tap-to-start.png}
	\caption{Log in}
	\label{fig:your4-tap-to-start}
\end{figure}
\begin{figure}[th]
	\centering
	\includegraphics[width=\textwidth]{images/screenshots/your4-play.png}
	\caption{Log in}
	\label{fig:your4-play}
\end{figure}

\begin{figure}[th]
	\centering
	\includegraphics[width=\textwidth]{images/screenshots/advertiser-advert-edit.png}
	\caption{Log in}
	\label{fig:advertiser-advert-edit}
\end{figure}
\begin{figure}[th]
	\centering
	\includegraphics[width=\textwidth]{images/screenshots/advertiser-campaigns.png}
	\caption{Log in}
	\label{fig:advertiser-campaigns}
\end{figure}
\begin{figure}[th]
	\centering
	\includegraphics[width=\textwidth]{images/screenshots/advertiser-advert.png}
	\caption{Log in}
	\label{fig:advertiser-advert}
\end{figure}
\begin{figure}[th]
	\centering
	\includegraphics[width=\textwidth]{images/screenshots/advertiser-impressions.png}
	\caption{Log in}
	\label{fig:advertiser-impressions}
\end{figure}
\begin{figure}[th]
	\centering
	\includegraphics[width=\textwidth]{images/screenshots/advertiser-adverts.png}
	\caption{Log in}
	\label{fig:advertiser-adverts}
\end{figure}
\begin{figure}[th]
	\centering
	\includegraphics[width=\textwidth]{images/screenshots/advertiser-campaign-demographics.png}
	\caption{Log in}
	\label{fig:advertiser-campaign-demographics}
\end{figure}
\begin{figure}[th]
	\centering
	\includegraphics[width=\textwidth]{images/screenshots/advertiser-campaign.png}
	\caption{Log in}
	\label{fig:advertiser-campaign}
\end{figure}
\begin{figure}[th]
	\centering
	\includegraphics[width=\textwidth]{images/screenshots/advertiser-campaign-schedule.png}
	\caption{Log in}
	\label{fig:advertiser-campaign-schedule}
\end{figure}

\subsection{Scheduled Tasks}\label{subsec:ScheduledTasks}
%list scheduled tasks here
\begin{description}
\item[EPG Retrieval]{EPG information is acquired by a cron job running on the LAMP server using the Atlas REST API.}
\end{description}